<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>search_method (二) | 57D02</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.Bo9O0SIK.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.Ccj-5EdJ.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.DwMa7PzH.js">
    <link rel="modulepreload" href="/assets/chunks/framework.B4b5TrON.js">
    <link rel="modulepreload" href="/assets/posts_search_method2.md.BFrPojzr.lean.js">
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="main-layout"><div class="navbar-container"><nav class="navbar"><div class="brand-group"><a class="brand-logo" href="/"><img src="https://resource-un4.pages.dev/article/yjtp.webp" alt="avatar"></a><a class="brand-text" href="/">57D02</a></div><div class="search-container"><div class="search-input"><input type="text" placeholder="动物怎么叫" class="search-field"><i class="fa-solid fa-magnifying-glass search-icon"></i></div></div><div class="menu-group"><!--[--><div class="el-dropdown"><!--[--><h3 class="menu-fitem el-tooltip__trigger el-tooltip__trigger" id="el-id-2175-225" role="button" tabindex="0" aria-controls="el-id-2175-226" aria-expanded="false" aria-haspopup="menu"><span><i class="fal fa-browser"></i> 我的网址 <i class="fa-light fa-angle-up arrow-icon"></i></span></h3><!--teleport start--><!--teleport end--><!--]--><!--v-if--></div><div class="el-dropdown"><!--[--><h3 class="menu-fitem el-tooltip__trigger el-tooltip__trigger" id="el-id-2175-229" role="button" tabindex="0" aria-controls="el-id-2175-230" aria-expanded="false" aria-haspopup="menu"><span><i class="fa-solid fa-list"></i> 更多功能 <i class="fa-light fa-angle-up arrow-icon"></i></span></h3><!--teleport start--><!--teleport end--><!--]--><!--v-if--></div><!--]--></div></nav></div><div class="el-scrollbar"><div class="el-scrollbar__wrap el-scrollbar__wrap--hidden-default" style="overflow-x:hidden;height:100vh;"><div class="el-scrollbar__view" style=""><!--[--><!----><div class="content-container"><div id="post-info"><div class="article-header" data-v-7d61ea6a><div class="header-title" data-v-7d61ea6a><h1 data-v-7d61ea6a>search_method (二)</h1></div><div class="meta-info" data-v-7d61ea6a><div class="author-info" data-v-7d61ea6a><i class="fa-light fa-user" data-v-7d61ea6a></i><span class="author" data-v-7d61ea6a>57D02</span></div><div class="divider" data-v-7d61ea6a></div><div class="date-info" data-v-7d61ea6a><i class="fa-light fa-calendar" data-v-7d61ea6a></i><time datetime="2024-10-04T17:34:45.000Z" data-v-7d61ea6a>2024年10月5日</time></div></div></div></div><div class="page-wrapper"><div class="page-card vp-doc"><div style="position:relative;"><div><h1 id="search-method-二" tabindex="-1">search_method（二） <a class="header-anchor" href="#search-method-二" aria-label="Permalink to &quot;search_method（二）&quot;">​</a></h1><p>​ 在篇文章中，将通过一个简单的图问题展示各种搜索算法的实例。不过在此之前，有必要先仔细研究搜索算法的定义。这篇文章更像是我思考的心路历程，逻辑比较混乱，后面再出一篇逻辑清晰的。</p><p>​ 因为我有一个朋友之前跟我一样学过运筹学，在运筹学中也学习了很多关于图的算法，例如Dijkstra最短路算法和弗洛伊德算法（floyd-warshall）来找到最短路径。但是实际上搜索问题和优化问题有着很大区别：以图（graph）问题为例，搜索问题的解只是<strong>目标节点</strong>，而优化问题的解由 <strong>初始节点-&gt;目标节点</strong> 的完整路径 构成。</p><p>接下来通过具体问题了解他们的区别：</p><p><img src="https://resource-un4.pages.dev/article/image-20241004180135844.png" alt="例题"></p><p>​ 上面是一道运筹优化问题的例题，我们将它简化成为一道搜索问题：只用他的地图，其他都不用。 同样的地图，骑手在v1（id=0）点，他现在想前往v37点（id=36），但是骑手没有地图，他只知道v1有三条路可以走，也知道路多长，但是不知道路通向的下一个节点有什么。该怎么在完全无知的情况下找到点v37呢？</p><p>这就是一道典型的搜索问题。我们先将图构建出来：</p><p><img src="https://resource-un4.pages.dev/article/image-20241004181301529.png" alt="ori_graph"></p><p>其中第n行第m列表示点vn通向点vm的距离，M表示并没有直接连通。此时我们的在点v1,也就是说只能访问图的第一行，而且不能确定通往的节点是否是我们想要的节点，只有确定前往那个节点（Vx）后,才能知道Vx是否是我们想要的节点，以及Vx能够前往什么地方（访问图第x行）。</p><p>我们使用BFS寻找。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>originGraph ,optimizedGraph = graph_process.read_graph(&#39;original_graph.xlsx&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(f&quot;originGraph:{originGraph}&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># we can use BFS to find the end_node</span></span>
<span class="line"><span>def BFS(graph, start, end):</span></span>
<span class="line"><span>    # create a queue </span></span>
<span class="line"><span>    queue = []</span></span>
<span class="line"><span>    # create a list to store the visited nodes</span></span>
<span class="line"><span>    visited = [start]</span></span>
<span class="line"><span>    # create a list to store the path</span></span>
<span class="line"><span>    path = []</span></span>
<span class="line"><span>    # add the start node to the queue</span></span>
<span class="line"><span>    queue.append(start)</span></span>
<span class="line"><span>    # while the queue is not empty</span></span>
<span class="line"><span>    while queue:</span></span>
<span class="line"><span>        # get the first element in the queue</span></span>
<span class="line"><span>        node = queue.pop(0)</span></span>
<span class="line"><span>        # add the node to the path</span></span>
<span class="line"><span>        path.append(node)</span></span>
<span class="line"><span>        # if the node is the end node</span></span>
<span class="line"><span>        if node == end:</span></span>
<span class="line"><span>            return path</span></span>
<span class="line"><span>        # get the neighbors of the node</span></span>
<span class="line"><span>        for x in range(len(graph)):</span></span>
<span class="line"><span>            # if the node is not visited and the distance between the node and the neighbor is not infinite</span></span>
<span class="line"><span>            if x not in visited and graph[node][x] != float(&#39;inf&#39;):</span></span>
<span class="line"><span>                # add the neighbor to the queue</span></span>
<span class="line"><span>                queue.append(x)</span></span>
<span class="line"><span>                visited.append(x)</span></span>
<span class="line"><span>    return path # 得出搜索路径</span></span>
<span class="line"><span></span></span>
<span class="line"><span># we assume that the start point is 0 (v1)</span></span>
<span class="line"><span># and the end point is 36 (v37)</span></span>
<span class="line"><span>path = BFS(originGraph, 0, 36)</span></span>
<span class="line"><span>print(f&quot;BFS search_path:{path} \nlen:{len(path)}&quot;)</span></span></code></pre></div><p>BFS的每一步都有详细注释，我就不赘述了。这时也许有人疑惑了，为什么不在探索邻居节点那一步就return呢？我再打个比方：外卖小哥要找的目标并不是v37，而是某个住在v37点里的小a，骑手不知道小a住在哪里，他只知道要找的人是小a。但是每一个点里都住了100户人，骑手每访问一个节点，就要挨家挨户问这一百户人家有没有叫小a的，这时就要将 <code>if node == end: </code>换成<code>if 小a in node: </code>，此时，我探索邻居节点是决定要前往的节点，而不是真实的探索了那些个节点的100户人家到底有没有小a.</p><p>(顺带解释，这个visited 列表并不是存储访问过的节点，而是储存计划前往的节点，目的是防止成环导致死循环，同一个点找了又找)</p><p>同时我们发现，BFS根本没用到点与点之间的距离，只是使用了点之间能否连通。没错，BFS就是根本不考虑这个。</p><p>最后，我们得到BFS的搜索路径：<code>BFS search_path:[0, 1, 3, 8, 2, 5, 4, 17, 9, 13, 6, 7, 10, 12, 18, 23, 14, 25, 11, 22, 15, 24, 36] len:23</code></p><p>也就是说，骑手在访问了22个节点每个节点100户人家后，才在最后一个节点找到了小a。</p><p>同样的，我们也可以使用DFS来搜索：DFS大多使用递归，因为递归自带栈操作。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>def DFS_in_recursion(graph, start, end, method_type):</span></span>
<span class="line"><span>    # create a list to store the path</span></span>
<span class="line"><span>    path = []</span></span>
<span class="line"><span>    # if method_type is 0 ,we use pre-order</span></span>
<span class="line"><span>    if method_type == 0:</span></span>
<span class="line"><span>        def dfs(graph, node, visited=None):</span></span>
<span class="line"><span>            nonlocal path</span></span>
<span class="line"><span>            if visited is None:</span></span>
<span class="line"><span>                visited = set()  # 初始化已访问节点集合</span></span>
<span class="line"><span>            if node not in visited:</span></span>
<span class="line"><span>                visited.add(node)  # 将当前节点标记为已访问</span></span>
<span class="line"><span>                path.append(node)  # 访问当前节点（你可以在这里进行其他处理）</span></span>
<span class="line"><span>                if node == end:</span></span>
<span class="line"><span>                    return True</span></span>
<span class="line"><span>                # get the neighbors of the node</span></span>
<span class="line"><span>                for x in range(len(graph)):</span></span>
<span class="line"><span>                    # if the node is not visited and the distance between the node and the neighbor is not infinite</span></span>
<span class="line"><span>                    if x not in visited and graph[node][x] != float(&#39;inf&#39;):</span></span>
<span class="line"><span>                        if dfs(graph, x, visited):</span></span>
<span class="line"><span>                            return True</span></span>
<span class="line"><span>            return False</span></span>
<span class="line"><span>    # if method_type is 1 ,we use post-order</span></span>
<span class="line"><span>    else:</span></span>
<span class="line"><span>        def dfs(graph, node, visited=None):</span></span>
<span class="line"><span>            nonlocal path</span></span>
<span class="line"><span>            if visited is None:</span></span>
<span class="line"><span>                visited = set()  # 初始化已访问节点集合</span></span>
<span class="line"><span>            if node not in visited:</span></span>
<span class="line"><span>                visited.add(node)  # 将当前节点标记为已访问</span></span>
<span class="line"><span>                # get the neighbors of the node</span></span>
<span class="line"><span>                for x in range(len(graph)):</span></span>
<span class="line"><span>                    # if the node is not visited and the distance between the node and the neighbor is not infinite</span></span>
<span class="line"><span>                    if x not in visited and graph[node][x] != float(&#39;inf&#39;):</span></span>
<span class="line"><span>                        if dfs(graph, x, visited):</span></span>
<span class="line"><span>                            return True</span></span>
<span class="line"><span>                path.append(node)  # 访问当前节点</span></span>
<span class="line"><span>                if node == end:</span></span>
<span class="line"><span>                    return True</span></span>
<span class="line"><span>            return False</span></span>
<span class="line"><span>    dfs(graph, start)</span></span>
<span class="line"><span>    return path # 得出搜索路径</span></span></code></pre></div><p>运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>path = DFS_in_recursion(originGraph, 0, 36, 0)</span></span>
<span class="line"><span>print(f&quot;DFS_in_recursion0 search_path:{path} \nlen:{len(path)}&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>path = DFS_in_recursion(originGraph, 0, 36, 1)</span></span>
<span class="line"><span>print(f&quot;DFS_in_recursion1 search_path:{path} \nlen:{len(path)}&quot;)</span></span></code></pre></div><p>得到相应结果</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>DFS_in_recursion pre-order search_path:[0, 1, 2, 6, 5, 9, 8, 13, 12, 4, 3, 17, 18, 24, 23, 36] </span></span>
<span class="line"><span>len:16</span></span>
<span class="line"><span>DFS_in_recursion post-order search_path:[7, 37, 39, 38, 33, 34, 35, 40, 30, 22, 21, 29, 28, 27, 19, 20, 16, 11, 10, 15, 14, 26, 25, 32, 31, 36] </span></span>
<span class="line"><span>len:26</span></span></code></pre></div><p>对比上述结果我们可以看到，当<strong>不考虑路程成本</strong>，仅考虑<strong>每个节点的搜索成本</strong>时，访问节点最少的是先序深度优先搜索，最菜的是后序深度优先搜索。</p><p>如果问题变成这样：</p><p>**问题1：**每个节点有100户人家，骑手从v1节点出发，寻找一个叫做小a的人（实际住在v37，但是骑手不知道），从出发节点开始挨家挨户的问：你是不是小a？</p><p>​ 不考虑节点到节点之前移动的开销，那么最快是先序深度优先搜索（问了1500-1600家），最慢是后序深度优先（2500-2600），宽度优先和后序深度优先差不了多少（2200-2300）</p><p>​ 但如果我们只考虑如何从出发节点最短路程走到目标节点，我们可以使用Dijkstra最短路算法。但当我回顾之前写的Dijkstra最短路算法时，我发现其实Dijkstra就是代价一致搜索加上路径记录，因此我在传统的代价一致搜索(UniformCostSearch)加上稍作修改就能得到Dijkstra算法，同时得到<strong>搜索路径</strong>和<strong>实际起点到终点</strong>的最短路径：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dijkstra</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ori_graph, start, end): </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    search_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># search_path use to record the order which the node is real visited</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ori_graph)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dist</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">np.full(n, np.inf)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # record the previous node (Dijk)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pred</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">np.full(n,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visitd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dist[start]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.inf</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        min_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">not</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> visitd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist[j]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                min_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        visitd.append(min_index)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ori_graph[min_index][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">np.inf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">not</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> visitd) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist[min_index]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">np.inf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist[min_index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ori_graph[min_index][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dist[j]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                dist[j]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dist[min_index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ori_graph[min_index][j]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                pred[j]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">min_index</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        search_path.append(min_index)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min_index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Dijkstra find the end node&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># real path form start to end (Dijk)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">start):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pred[current]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        path.insert(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,current)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path ,search_path</span></span></code></pre></div><p>实际上Dijkstra算法就是代价一致搜索加上<code>pred</code>记录前置点，再通过最后一部分输出最短路：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>current = end</span></span>
<span class="line"><span>    path =[] # real path form start to end (Dijk)</span></span>
<span class="line"><span>    while(current!=start):</span></span>
<span class="line"><span>        current = pred[current]</span></span>
<span class="line"><span>        path.insert(0,current)</span></span></code></pre></div><p>运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>path ,search_path = Dijkstra(originGraph, 0, 36)</span></span>
<span class="line"><span>print(f&#39;Dijkstra_Path:{path}\nsearch_path:{search_path}\nlen:{len(search_path)}&#39;)</span></span></code></pre></div><p>结果得到：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Dijkstra_Path:[0, 8, 13, 12, 18, 24, 31, 36]</span></span>
<span class="line"><span>search_path:[0, 1, 8, 5, 6, 2, 9, 11, 10, 13, 16, 15, 14, 12, 20, 7, 28, 19, 21, 29, 27, 18, 3, 35, 30, 25, 26, 24, 22, 17, 4, 40, 23, 34, 32, 39, 31, 38, 37, 33, 36]</span></span>
<span class="line"><span>len:41</span></span></code></pre></div><p>我们分析数据：search_path 里的顺序时节点访问的顺序，而代价一致搜索访问节点的顺序是按照每个节点离初始节点的距离来决定的，因此由searchpath可见，v37 (36)是最后一个，也就是v37是所有点中距离v1最远的点。如果搜索不考虑点之间移动成本，只考虑每个节点的访问成本时，代价一致搜索(Dijkstra)反而是效率最低下的。但如果骑手不在乎花多少时间才能找到小a,只希望以后再去小a家时能最快，<strong>完整的路径</strong>才是我的目标，那么代价一致搜索才能够完成。</p><p>那么能否同时兼顾搜索效率和路径的优略呢？当然有。A*算法就是兼顾了二者的搜索算法。</p><p>欲知后事如何，且听下回分解。</p></div></div></div><div class="sidebar"><div class="profile-card has-border"><div class="avatar-wrapper"><img src="https://resource-un4.pages.dev/article/yjtp.webp" alt="57D02" class="avatar"></div><div class="profile-content"><h2 class="name">57D02</h2><div class="position">全栈开发、优化算法爱好者</div><p class="bio">呜呜呜呜呜呜</p><div class="social-links"><!--[--><a href="https://github.com/57Darling02/" target="_blank" class="social-item" title="GitHub"><i class="fa-brands fa-github"></i></a><a href="57Darling02@outlook.com" target="_blank" class="social-item" title="邮箱"><i class="fa-regular fa-envelope"></i></a><!--]--></div></div></div><div class="sidebar-stay"><div class="toc-card" data-v-73916423><i class="fas fa-columns" data-v-73916423></i><span class="toc-title" style="font-weight:600;" data-v-73916423>目录导航</span><div class="el-scrollbar" data-v-73916423><div class="el-scrollbar__wrap el-scrollbar__wrap--hidden-default" style=""><div class="el-scrollbar__view" style=""><!--[--><div class="empty-tip" data-v-73916423>暂无目录</div><!--]--></div></div><!--[--><div class="el-scrollbar__bar is-horizontal" style="display:none;"><div class="el-scrollbar__thumb" style="width:;transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical" style="display:none;"><div class="el-scrollbar__thumb" style="height:;transform:translateY(0%);"></div></div><!--]--></div></div><!----></div></div></div></div><div class="footer-container" style="color:white;"><Badge type="tip">Copyright © 2025-present 57D02</Badge></div><!--]--></div></div><!--[--><div class="el-scrollbar__bar is-horizontal" style="display:none;"><div class="el-scrollbar__thumb" style="width:;transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical" style="display:none;"><div class="el-scrollbar__thumb" style="height:;transform:translateY(0%);"></div></div><!--]--></div></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about_index.md\":\"BXn1AeTD\",\"index.md\":\"BuxDNdUi\",\"posts_20240916-2.md\":\"qXz9xXdf\",\"posts_20240916.md\":\"Cen_2V7f\",\"posts_20240923.md\":\"DAEEFOEx\",\"posts_20241026_无眠夜.md\":\"mRCAaeIp\",\"posts_51stc_uart.md\":\"C8WhIvzO\",\"posts_cloudflare_free.md\":\"5KsxQB8V\",\"posts_columngeneration.md\":\"BkkART46\",\"posts_ftp.md\":\"Cpux9fJh\",\"posts_hahha.md\":\"BBm_T87b\",\"posts_hello-world.md\":\"C3NzfzEN\",\"posts_hexo快速创作指南.md\":\"Cudi9z-k\",\"posts_ksweb.md\":\"C-Q2s2ds\",\"posts_sao-uw-1.md\":\"B9AXICYl\",\"posts_sao-uw-2.md\":\"Dzmhcj3w\",\"posts_sao-uw-3.md\":\"csZI7z0q\",\"posts_sao-uw-4.md\":\"y2XCA12O\",\"posts_sao-uw-5.md\":\"C1IkThxM\",\"posts_sao-uw-6.md\":\"XdBEHyDN\",\"posts_sao-uw-7.md\":\"CSU_CSRV\",\"posts_sao-uw-8.md\":\"COUh4tH3\",\"posts_search_method2.md\":\"BFrPojzr\",\"posts_searchmethod.md\":\"AypBoSae\",\"posts_searchmethods3.md\":\"B2kMEo_n\",\"posts_交叉口的轨迹规划的一些探索.md\":\"xDbVEZE2\",\"posts_单纯形法.md\":\"CYalUIwv\",\"posts_如何写一篇hexo博客.md\":\"UFJ0G-X5\",\"posts_嵌入式学习.md\":\"CHNIKTSt\",\"posts_我家邻居蛇精病.md\":\"B4oovZt2\",\"posts_生产工具.md\":\"DRdw0RLl\",\"posts_运筹线性规划.md\":\"DM0khA-z\",\"posts_逆向初体验.md\":\"D67P5eLB\",\"posts_钟情.md\":\"CD2A2lW-\",\"readme.md\":\"DVOXxAtU\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"57D02\",\"description\":\"A VitePress Site\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"bgImage\":{\"src\":\"\",\"alt\":\"57D02\"},\"mainTitle\":\"57D02\",\"subTitles\":[\"全栈开发爱好者\",\"算法优化爱好者\",\"软件开发爱好者\",\"安卓与嵌入式开发爱好者\"],\"defaultauthor\":\"57D02\",\"logo\":\"https://resource-un4.pages.dev/article/yjtp.webp\",\"siteTitle\":\"57D02\",\"menuItems\":[{\"label\":\"我的网址\",\"icon\":\"fal fa-browser\",\"children\":[{\"key\":\"action1\",\"label\":\"闪装智拼\",\"icon\":\"fas fa-cubes\",\"link\":\"https://box.57d02.cn\"},{\"key\":\"action2\",\"label\":\"alist云盘\",\"icon\":\"fa-solid fa-square\",\"link\":\"https://alist.57d02.cn\"}]},{\"label\":\"更多功能\",\"icon\":\"fa-solid fa-list\",\"children\":[{\"key\":\"action1\",\"label\":\"404测试\",\"icon\":\"fa-solid fa-circle\",\"link\":\"404\"},{\"key\":\"action2\",\"label\":\"关于\",\"icon\":\"fa-solid fa-square\",\"link\":\"about/index\"},{\"key\":\"action3\",\"label\":\"归档\",\"icon\":\"fa-solid fa-star\",\"link\":\"posts/hahha\"}]}],\"avatar\":\"https://resource-un4.pages.dev/article/yjtp.webp\",\"name\":\"57D02\",\"position\":\"全栈开发、优化算法爱好者\",\"bio\":\"呜呜呜呜呜呜\",\"socialLinks\":[{\"name\":\"GitHub\",\"icon\":\"fa-brands fa-github\",\"url\":\"https://github.com/57Darling02/\"},{\"name\":\"邮箱\",\"icon\":\"fa-regular fa-envelope\",\"url\":\"57Darling02@outlook.com\"}],\"footer\":{\"message\":\"VitePress\",\"copyright\":\"Copyright © 2025-present 57D02\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>