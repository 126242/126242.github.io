import{_ as i,c as a,b as n,p}from"./chunks/framework.h8ZaMGLV.js";const g=JSON.parse('{"title":"agent学习(1)","description":"","frontmatter":{"title":"agent学习(1)","date":"2024-09-16T17:56:35.000Z","tags":"人工智能","cover":"https://resource-un4.pages.dev/article/output_max_compressed.webp","categories":"Learn","copyright":true},"headers":[],"relativePath":"posts/20240916.md","filePath":"posts/20240916.md","lastUpdated":1740504357000}'),l={name:"posts/20240916.md"};function e(t,s,h,k,E,r){return n(),a("div",null,s[0]||(s[0]=[p(`<h1 id="agent学习" tabindex="-1">Agent学习 <a class="header-anchor" href="#agent学习" aria-label="Permalink to &quot;Agent学习&quot;">​</a></h1><p>人工智能是最新兴的科学与工程领域之一，它是使机器能够像人一样思考、像人一样行动，并且这些思考和行动都是合理的；它的研究目标是试图理解智能实体，并且试图建造智能实体。人工智能既是科学也是工程，它与任何智力工作相关，所以它是一个普遍的研究领域，是一门科学，同时它还涉及对智能系统的开发和应用，可以说它是一门工程。</p><p>简单分析两种类型的智能体（agent）：基于效用的agent和基于目标的agent</p><h2 id="基于目标的agent" tabindex="-1">基于目标的agent <a class="header-anchor" href="#基于目标的agent" aria-label="Permalink to &quot;基于目标的agent&quot;">​</a></h2><pre><code>目标导向型智能体会根据其所处环境来选择一系列动作，以实现某个具体目标。它不考虑动作的长期效用，只要能够达到目标即可。
</code></pre><p><strong>伪代码步骤</strong>：</p><ol><li>通过感知(Sensors)和预设程序获取当前状态(State) 、世界运行规则、可以做出的动作。</li><li>判断状态是否达成目标</li><li>如果达成目标，结束。</li><li>如果未达成目标，判断各个动作后状态的改变，从中选择可以接近目标的动作。</li><li>执行动作，更新状态。</li></ol><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GoalBasedAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, initial_state, goal_state):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initial_state</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.goal_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> goal_state</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> perceive_environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 获取当前环境状态</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> goal_achieved</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 判断是否达成目标</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.goal_state</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> choose_action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, state):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 根据当前状态选择下一步动作</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 动作应让 agent 更接近目标</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 这里的 action 逻辑根据具体问题不同而不同</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    possible_actions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;action1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;action2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;action3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> possible_actions:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> helpful:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> update_state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, action):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 根据动作更新状态</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.state_transition(action)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> state_transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, action):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 模拟状态转移（不同问题的实现不同）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> action</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.goal_achieved():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.perceive_environment()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        action </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.choose_action(current_state)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.update_state(action)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Goal achieved!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="基于效用的agent" tabindex="-1">基于效用的agent <a class="header-anchor" href="#基于效用的agent" aria-label="Permalink to &quot;基于效用的agent&quot;">​</a></h2><p>​ 基于效用的智能体不仅仅追求达到某个目标，还会通过一个效用函数来评估动作的收益，选择能最大化效用的动作。它可以权衡多种可能的动作和路径，选择最优的行动策略。这与基于目标的agent实现方式非常相似，不同的地方在于行动的选择上。</p><p>​ 基于目标的agent智能做出动作选择时，能够选择的动作只有“好”与“不好”。当有多个“好”的行动时，并不能实现选择“最好”的行动。</p><p>​ 基于效用的agent会通过效用(Utility)指标，对每个动作进行评估后，选择出“最好”的行动去执行。</p><p>​ 伪代码与基于上文仅仅选择行动上有差异.</p><pre><code>class UtilityBasedAgent:
    def __init__(self, initial_state, goal_state, utility_function):
        self.state = initial_state
        self.goal_state = goal_state
        self.utility_function = utility_function
	def perceive_environment(self):
    # 获取当前环境状态
    	return self.state

    def goal_achieved(self):
        # 判断是否达成目标
        return self.state == self.goal_state

    def evaluate_actions(self, state):
        # 根据效用函数评估每个可能动作的效用值
        possible_actions = [&#39;action1&#39;, &#39;action2&#39;, &#39;action3&#39;]
        best_action = None
        max_utility = float(&#39;-inf&#39;)
        for action in possible_actions:
            utility = self.utility_function(state, action)
            if utility &gt; max_utility:
                max_utility = utility
                best_action = action
        return best_action

    def update_state(self, action):
        # 根据动作更新状态
        self.state = self.state_transition(action)

    def state_transition(self, action):
        # 模拟状态转移
        return action

    def run(self):
        while not self.goal_achieved():
            current_state = self.perceive_environment()
            action = self.evaluate_actions(current_state)
            self.update_state(action)
        print(&quot;Goal achieved with maximum utility!&quot;)
</code></pre><h2 id="一个基于吃豆人agent的简单示例" tabindex="-1">一个基于吃豆人agent的简单示例 <a class="header-anchor" href="#一个基于吃豆人agent的简单示例" aria-label="Permalink to &quot;一个基于吃豆人agent的简单示例&quot;">​</a></h2><p>定义一个吃逗人pacman的类，吃豆人包括</p><p>1.自身的状态 和 动作空间 ，目标状态 最高分 （分就是效用）.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import heapq</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 定义地图，&#39; &#39;代表空地，&#39;#&#39;代表墙壁，&#39;.&#39;代表豆子，&#39;P&#39;代表吃豆人起始位置</span></span>
<span class="line"><span>map_grid = [</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;.&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;.&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;.&#39;, &#39;.&#39;, &#39; &#39;, &#39;.&#39;, &#39;.&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;P&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;.&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;.&#39;, &#39;#&#39;],</span></span>
<span class="line"><span>    [&#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;, &#39;#&#39;]</span></span>
<span class="line"><span>]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 定义方向：上，下，左，右</span></span>
<span class="line"><span>DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># A* 搜索算法</span></span>
<span class="line"><span>def a_star_search(grid, start, end):</span></span>
<span class="line"><span>    rows, cols = len(grid), len(grid[0])</span></span>
<span class="line"><span>    open_set = []</span></span>
<span class="line"><span>    heapq.heappush(open_set, (0, start))</span></span>
<span class="line"><span>    g_score = {start: 0}</span></span>
<span class="line"><span>    f_score = {start: heuristic(start, end)}</span></span>
<span class="line"><span>    came_from = {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    while open_set:</span></span>
<span class="line"><span>        current = heapq.heappop(open_set)[1]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if current == end:</span></span>
<span class="line"><span>            return reconstruct_path(came_from, current)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        for dx, dy in DIRECTIONS:</span></span>
<span class="line"><span>            neighbor = (current[0] + dx, current[1] + dy)</span></span>
<span class="line"><span>            if 0 &lt;= neighbor[0] &lt; rows and 0 &lt;= neighbor[1] &lt; cols:</span></span>
<span class="line"><span>                if grid[neighbor[0]][neighbor[1]] == &#39;#&#39;:</span></span>
<span class="line"><span>                    continue  # 墙壁，跳过</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                tentative_g_score = g_score[current] + 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                if neighbor not in g_score or tentative_g_score &lt; g_score[neighbor]:</span></span>
<span class="line"><span>                    came_from[neighbor] = current</span></span>
<span class="line"><span>                    g_score[neighbor] = tentative_g_score</span></span>
<span class="line"><span>                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)</span></span>
<span class="line"><span>                    heapq.heappush(open_set, (f_score[neighbor], neighbor))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def heuristic(a, b):</span></span>
<span class="line"><span>    return abs(a[0] - b[0]) + abs(a[1] - b[1])</span></span>
<span class="line"><span></span></span>
<span class="line"><span>def reconstruct_path(came_from, current):</span></span>
<span class="line"><span>    path = [current]</span></span>
<span class="line"><span>    while current in came_from:</span></span>
<span class="line"><span>        current = came_from[current]</span></span>
<span class="line"><span>        path.append(current)</span></span>
<span class="line"><span>    return path[::-1]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 吃豆人 Agent</span></span>
<span class="line"><span>class PacManAgent:</span></span>
<span class="line"><span>    def __init__(self, grid):</span></span>
<span class="line"><span>        self.grid = grid</span></span>
<span class="line"><span>        self.position = self.find_pacman(grid)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def find_pacman(self, grid):</span></span>
<span class="line"><span>        for i in range(len(grid)):</span></span>
<span class="line"><span>            for j in range(len(grid[0])):</span></span>
<span class="line"><span>                if grid[i][j] == &#39;P&#39;:</span></span>
<span class="line"><span>                    return (i, j)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def get_beans(self):</span></span>
<span class="line"><span>        beans = []</span></span>
<span class="line"><span>        for i in range(len(self.grid)):</span></span>
<span class="line"><span>            for j in range(len(self.grid[0])):</span></span>
<span class="line"><span>                if self.grid[i][j] == &#39;.&#39;:</span></span>
<span class="line"><span>                    beans.append((i, j))</span></span>
<span class="line"><span>        return beans</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def move(self):</span></span>
<span class="line"><span>        beans = self.get_beans()</span></span>
<span class="line"><span>        if not beans:</span></span>
<span class="line"><span>            print(&quot;All beans eaten!&quot;)</span></span>
<span class="line"><span>            return</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        nearest_bean = min(beans, key=lambda bean: heuristic(self.position, bean))</span></span>
<span class="line"><span>        path = a_star_search(self.grid, self.position, nearest_bean)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if path:</span></span>
<span class="line"><span>            next_move = path[1]</span></span>
<span class="line"><span>            self.grid[self.position[0]][self.position[1]] = &#39; &#39;</span></span>
<span class="line"><span>            self.position = next_move</span></span>
<span class="line"><span>            if self.grid[next_move[0]][next_move[1]] == &#39;.&#39;:</span></span>
<span class="line"><span>                self.grid[next_move[0]][next_move[1]] = &#39;P&#39;</span></span>
<span class="line"><span>            else:</span></span>
<span class="line"><span>                self.grid[next_move[0]][next_move[1]] = &#39;P&#39;</span></span>
<span class="line"><span>                </span></span>
<span class="line"><span>        self.print_grid()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def print_grid(self):</span></span>
<span class="line"><span>        for row in self.grid:</span></span>
<span class="line"><span>            print(&#39;&#39;.join(row))</span></span>
<span class="line"><span>        print()</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 初始化吃豆人 Agent 并运行</span></span>
<span class="line"><span>pacman =  PacManAgent(map_grid)</span></span>
<span class="line"><span>while True:</span></span>
<span class="line"><span>    pacman.move()</span></span>
<span class="line"><span>    # 为了避免无限循环，当没有豆子时停止</span></span>
<span class="line"><span>    if not pacman.get_beans():</span></span>
<span class="line"><span>        break</span></span></code></pre></div><p>这个代码实现了一个使用A<em>搜索算法的吃豆人(Pac-Man) Agent，负责在二维网格地图中寻找并吃掉所有豆子。代码分为多个部分，涉及地图初始化、A</em>搜索算法、吃豆人Agent的动作和移动逻辑。</p><h3 id="代码分解" tabindex="-1">代码分解 <a class="header-anchor" href="#代码分解" aria-label="Permalink to &quot;代码分解&quot;">​</a></h3><ol><li><p><strong>地图定义 (<code>map_grid</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map_grid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;P&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><ul><li>这个二维数组定义了吃豆人的游戏地图。<code>&#39;#&#39;</code>表示墙壁，<code>&#39;.&#39;</code>表示豆子，<code>&#39;P&#39;</code>是吃豆人的起始位置，<code>&#39; &#39;</code>是空地。</li><li>吃豆人从起始位置(<code>&#39;P&#39;</code>)出发，目标是吃掉所有豆子(<code>&#39;.&#39;</code>)。</li></ul></li><li><p><strong>方向定义 (<code>DIRECTIONS</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DIRECTIONS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span></code></pre></div><ul><li>定义了吃豆人的四个移动方向：上、下、左、右，分别用坐标偏移来表示。 <ul><li><code>(-1, 0)</code> 表示上移一格</li><li><code>(1, 0)</code> 表示下移一格</li><li><code>(0, -1)</code> 表示左移一格</li><li><code>(0, 1)</code> 表示右移一格</li></ul></li></ul></li><li><p><em><em>A</em> 搜索算法 (<code>a_star_search</code>)</em>*</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a_star_search</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, start, end):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    ...</span></span></code></pre></div><ul><li><p>这是A*路径搜索算法，用于找到从起点到目标点（豆子）之间的最短路径。</p></li><li><p><strong>主要步骤</strong>：</p><ul><li>使用 <code>heapq</code> 实现的优先队列维护待搜索的节点（<code>open_set</code>），每次从队列中取出估计距离最短的节点进行扩展。</li><li><code>g_score</code> 记录当前节点到起点的代价，<code>f_score</code> 估算从当前节点经过目标点的总代价（启发式函数+实际代价）。</li><li>对每个节点的邻居（上下左右）进行搜索，更新代价，如果找到目标则返回路径。</li></ul></li><li><p><strong>关键函数</strong>：</p><ul><li><code>heuristic(a, b)</code>：使用曼哈顿距离作为启发式函数，计算当前节点到目标节点的预估距离。</li><li><code>reconstruct_path(came_from, current)</code>：当找到目标时，重建从起点到终点的路径。</li></ul></li></ul></li><li><p><strong>吃豆人 Agent (<code>PacManAgent</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PacManAgent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, grid):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grid</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.find_pacman(grid)</span></span></code></pre></div><ul><li>吃豆人 Agent 负责在地图上移动，吃掉所有豆子。</li><li><strong>主要方法</strong>： <ul><li><code>find_pacman(grid)</code>：在地图中查找吃豆人的初始位置（&#39;P&#39;）。</li><li><code>get_beans()</code>：扫描整个地图，找到所有豆子的位置。</li><li><code>move()</code>：找到离吃豆人最近的豆子，并使用A*算法计算最短路径，然后移动吃豆人到豆子的位置。</li><li><code>print_grid()</code>：打印当前地图，用于显示吃豆人的当前位置和地图的状态变化。</li></ul></li></ul></li><li><p><strong>查找吃豆人的位置 (<code>find_pacman</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> find_pacman</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, grid):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid)):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grid[i][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;P&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i, j)</span></span></code></pre></div><ul><li>遍历整个地图，找到吃豆人的初始位置 <code>&#39;P&#39;</code>，并返回其坐标。</li></ul></li><li><p><strong>获取所有豆子的位置 (<code>get_beans</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_beans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    beans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid)):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[i][j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                beans.append((i, j))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> beans</span></span></code></pre></div><ul><li>遍历地图，找到所有豆子（<code>&#39;.&#39;</code>）的位置，并返回包含所有豆子坐标的列表。</li></ul></li><li><p><strong>吃豆人移动 (<code>move</code>)</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    beans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.get_beans()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> beans:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;All beans eaten!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nearest_bean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beans, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bean: heuristic(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position, bean))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_star_search(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position, nearest_bean)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        next_move </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next_move</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]][next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]][next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;P&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.grid[next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]][next_move[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;P&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.print_grid()</span></span></code></pre></div><ul><li><strong>逻辑流程</strong>： <ol><li>调用 <code>get_beans()</code> 获取当前地图上的所有豆子。</li><li>如果没有豆子，打印 &quot;All beans eaten!&quot; 并停止。</li><li>使用 <code>min()</code> 和 <code>heuristic()</code> 找到最近的豆子。</li><li>调用 <code>a_star_search()</code> 计算吃豆人到该豆子的最短路径。</li><li>移动吃豆人到路径上的下一个位置，更新地图： <ul><li>吃豆人当前位置变为空地 <code>&#39; &#39;</code>。</li><li>吃豆人移动到的新位置变为 <code>&#39;P&#39;</code>（如果该位置有豆子，则吃掉豆子）。</li></ul></li><li>打印当前地图状态。</li></ol></li></ul></li><li><p><strong>运行吃豆人 Agent</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pacman </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PacManAgent(map_grid)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pacman.move()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pacman.get_beans():</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span></code></pre></div><ul><li>创建吃豆人 Agent，传入初始地图。</li><li>不断调用 <code>pacman.move()</code> 让吃豆人寻找豆子并移动，直到地图上没有豆子为止。</li></ul></li></ol><hr><h3 id="运行逻辑" tabindex="-1">运行逻辑： <a class="header-anchor" href="#运行逻辑" aria-label="Permalink to &quot;运行逻辑：&quot;">​</a></h3><ol><li><p>创建吃豆人 Agent，传入初始地图。</p></li><li><p>不断调用 <code>pacman.move()</code></p></li><li><p>(<code>get_beans</code>)遍历地图，找到所有豆子（<code>&#39;.&#39;</code>）的位置，并返回包含所有豆子坐标的列表。</p></li><li><p>使用 <code>min()</code> 和 <code>heuristic()</code> 找到最近的豆子。</p></li><li><p>调用 <code>a_star_search()</code> 计算吃豆人到该豆子的最短路径。</p><ol><li>使用 <code>heapq</code> 实现的优先队列维护待搜索的节点（<code>open_set</code>），每次从队列中取出估计距离最短的节点进行扩展。</li><li><code>g_score</code> 记录当前节点到起点的代价，<code>f_score</code> 估算从当前节点经过目标点的总代价（启发式函数+实际代价）。</li><li>对每个节点的邻居（上下左右）进行搜索，更新代价，如果找到目标则返回路径。</li></ol></li><li><p>移动吃豆人到路径上的下一个位置，更新地图：</p><ul><li>吃豆人当前位置变为空地 <code>&#39; &#39;</code>。</li><li>吃豆人移动到的新位置变为 <code>&#39;P&#39;</code>（如果该位置有豆子，则吃掉豆子）。</li></ul></li><li><p>打印当前地图状态。</p></li></ol><h3 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h3><ul><li>该代码使用了A*搜索算法帮助吃豆人Agent在地图上移动，寻找并吃掉所有豆子。</li><li><code>move()</code> 函数根据吃豆人当前位置，通过启发式算法找到最近的豆子，并沿最短路径前进。</li><li><code>a_star_search()</code> 负责寻找最优路径，<code>get_beans()</code> 则找到地图上的所有豆子。</li><li>最后，代码会不断执行吃豆人的移动，直到地图上所有豆子都被吃掉。</li></ul><h3 id="后续" tabindex="-1">后续： <a class="header-anchor" href="#后续" aria-label="Permalink to &quot;后续：&quot;">​</a></h3><p><strong>a.</strong> 添加鬼怪在地图上移动的逻辑，让吃豆人不仅要吃豆子，还要躲避鬼怪。<br><strong>b.</strong> 实现吃豆人吃掉大豆子后可以反过来追逐鬼怪的功能，模拟真实的吃豆人游戏体验。</p>`,28)]))}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
