<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>嵌入式学习 | 57D02</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/assets/style.Blfz7q6r.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.B66H20Jc.js"></script>
    <link rel="modulepreload" href="/assets/chunks/theme.WHOrd9Uv.js">
    <link rel="modulepreload" href="/assets/chunks/framework.DsqwWaOE.js">
    <link rel="modulepreload" href="/assets/posts_嵌入式学习.md.wZuBU8TE.lean.js">
    <link rel="icon" href="/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><!--[--><!----><div class="main-layout"><div class="navbar-container"><!--[--><!--[--><div class="el-overlay" style="z-index:2085;display:none;"><!--[--><!--[--><div aria-modal="true" aria-labelledby="el-id-3918-448" aria-describedby="el-id-3918-449" style="background-color:antiquewhite;width:90%;" class="el-drawer rtl" role="dialog"><span class="el-drawer__sr-focus" tabindex="-1"></span><header class="el-drawer__header"><!--[--><span id="el-id-3918-448" role="heading" aria-level="2" class="el-drawer__title"></span><!--]--><button aria-label="Close this dialog" class="el-drawer__close-btn" type="button"><i class="el-icon el-drawer__close" style=""><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024"><path fill="currentColor" d="M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"></path></svg><!--]--></i></button></header><!--v-if--><!--v-if--></div><!--]--><!--]--></div><!--]--><nav class="navbar"><div class="brand-group"><a class="brand-logo" href="/"><img src="https://resource-un4.pages.dev/article/yjtp.webp" alt="avatar"></a><a class="brand-text" href="/">57D02</a></div><div class="search-container"><!----></div><div class="menu-group"><div class="dropitem"><!--[--><div class="el-dropdown"><!--[--><h3 class="menu-fitem el-tooltip__trigger el-tooltip__trigger" id="el-id-3918-450" role="button" tabindex="0" aria-controls="el-id-3918-451" aria-expanded="false" aria-haspopup="menu"><span><i class="fal fa-browser"></i> 我的网址 <i class="fa-light fa-angle-up arrow-icon"></i></span></h3><!--teleport start--><!--teleport end--><!--]--><!--v-if--></div><div class="el-dropdown"><!--[--><h3 class="menu-fitem el-tooltip__trigger el-tooltip__trigger" id="el-id-3918-454" role="button" tabindex="0" aria-controls="el-id-3918-455" aria-expanded="false" aria-haspopup="menu"><span><i class="fa-solid fa-list"></i> 更多功能 <i class="fa-light fa-angle-up arrow-icon"></i></span></h3><!--teleport start--><!--teleport end--><!--]--><!--v-if--></div><!--]--></div><div class="sbbtn"><h3 class="menu-fitem"><span><i class="fa-solid fa-list"></i></span></h3></div></div></nav><!--]--></div><div class="el-scrollbar"><div class="el-scrollbar__wrap el-scrollbar__wrap--hidden-default" style="overflow-x:hidden;height:100vh;"><div class="el-scrollbar__view" style=""><!--[--><div class="docPage Page"><div id="post-info"><div class="article-header" data-v-ee2e6c1c><div class="header-title" data-v-ee2e6c1c><h1 data-v-ee2e6c1c>嵌入式学习</h1></div><div class="meta-info" data-v-ee2e6c1c><div class="author-info" data-v-ee2e6c1c><i class="fa-light fa-user" data-v-ee2e6c1c></i><span class="author" data-v-ee2e6c1c>57D02</span></div><div class="divider" data-v-ee2e6c1c></div><div class="date-info" data-v-ee2e6c1c><i class="fa-light fa-calendar" data-v-ee2e6c1c></i><time datetime="2024-10-07T20:34:45.000Z" data-v-ee2e6c1c>2024年10月8日</time></div></div></div></div><div class="content-container"><div class="page-wrapper"><div class="a-card vp-doc"><div style="position:relative;"><div><h1 id="嵌入式学习" tabindex="-1">嵌入式学习 <a class="header-anchor" href="#嵌入式学习" aria-label="Permalink to &quot;嵌入式学习&quot;">​</a></h1><h2 id="汇编语言" tabindex="-1">汇编语言 <a class="header-anchor" href="#汇编语言" aria-label="Permalink to &quot;汇编语言&quot;">​</a></h2><p>汇编语言是一种低级编程语言，直接与计算机的硬件架构紧密相关。在汇编语言中，理解操作数及其寻址方式对于编写高效、有效的程序至关重要。以下将详细解释源操作数与目标操作数的概念，并通过常见指令（如 ADD、PUSH、MOV、ANL、MOVC、MOVX）的示例，说明在不同条件下如何选择适当的寻址方式。</p><h3 id="一、源操作数与目标操作数" tabindex="-1">一、源操作数与目标操作数 <a class="header-anchor" href="#一、源操作数与目标操作数" aria-label="Permalink to &quot;一、源操作数与目标操作数&quot;">​</a></h3><h4 id="_1-源操作数-source-operand" tabindex="-1">1. 源操作数（Source Operand） <a class="header-anchor" href="#_1-源操作数-source-operand" aria-label="Permalink to &quot;1. 源操作数（Source Operand）&quot;">​</a></h4><p>源操作数是指在指令执行过程中提供数据的操作数。它们通常是指令操作的输入。</p><h4 id="_2-目标操作数-destination-operand" tabindex="-1">2. 目标操作数（Destination Operand） <a class="header-anchor" href="#_2-目标操作数-destination-operand" aria-label="Permalink to &quot;2. 目标操作数（Destination Operand）&quot;">​</a></h4><p>目标操作数是指指令执行后存放结果的操作数。它们通常是指令操作的输出。</p><p><strong>例如：</strong> 在指令 <code>ADD A, #0x05</code> 中：</p><ul><li>源操作数是立即数 <code>#0x05</code></li><li>目标操作数是寄存器 <code>A</code></li></ul><h3 id="二、不同指令的寻址方式要求" tabindex="-1">二、不同指令的寻址方式要求 <a class="header-anchor" href="#二、不同指令的寻址方式要求" aria-label="Permalink to &quot;二、不同指令的寻址方式要求&quot;">​</a></h3><p>当然！以下是8051微控制器中常用的逻辑指令和跳转指令的详细解释，包括它们的功能、允许的目标和源操作数的寻址方式。这将帮助你更好地理解和应用这些指令。</p><hr><h2 id="_1-寻址方式概述" tabindex="-1"><strong>1. 寻址方式概述</strong> <a class="header-anchor" href="#_1-寻址方式概述" aria-label="Permalink to &quot;**1. 寻址方式概述**&quot;">​</a></h2><p>在8051汇编语言中，常见的寻址方式包括：</p><ul><li><strong>立即寻址（Immediate Addressing）</strong>：使用常数值作为操作数，如 <code>#0xFF</code>。</li><li><strong>寄存器寻址（Register Addressing）</strong>：使用通用寄存器（R0-R7）作为操作数。</li><li><strong>直接寻址（Direct Addressing）</strong>：使用内部RAM或特殊功能寄存器（SFR）的地址作为操作数，如 <code>20H</code>。</li><li><strong>位寻址（Bit Addressing）</strong>：操作特定位，如 <code>P1.0</code>。</li><li><strong>寄存器间接寻址（Register Indirect Addressing）</strong>：使用指针寄存器（如 <code>@R0</code>、<code>@R1</code>）作为操作数。</li><li><strong>代码存储器间接寻址（Code Indirect Addressing）</strong>：使用 <code>MOVC</code> 指令结合 <code>DPTR</code> 或 <code>A</code> 访问代码存储器。</li></ul><hr><h2 id="_2-逻辑指令详解" tabindex="-1"><strong>2. 逻辑指令详解</strong> <a class="header-anchor" href="#_2-逻辑指令详解" aria-label="Permalink to &quot;**2. 逻辑指令详解**&quot;">​</a></h2><h3 id="_2-1-cpl-complement-取反" tabindex="-1"><strong>2.1 CPL（Complement，取反）</strong> <a class="header-anchor" href="#_2-1-cpl-complement-取反" aria-label="Permalink to &quot;**2.1 CPL（Complement，取反）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>对目标操作数的每一位进行取反（0变1，1变0）。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li>对寄存器：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CPL A          ; 取反累加器A</span></span></code></pre></div></li><li>对位地址：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CPL bit        ; 取反特定位，如 CPL P1.0</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li><li>位地址（位寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>CPL</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CPL A          ; 如果 A = 0x0F, 取反后 A = 0xF0</span></span>
<span class="line"><span>CPL P1.0       ; 如果 P1.0 = 0, 取反后 P1.0 = 1</span></span></code></pre></div></li></ul><h3 id="_2-2-setb-set-bit-置位" tabindex="-1"><strong>2.2 SETB（Set Bit，置位）</strong> <a class="header-anchor" href="#_2-2-setb-set-bit-置位" aria-label="Permalink to &quot;**2.2 SETB（Set Bit，置位）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>将目标位设置为1。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li>对位地址：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETB P1.0       ; 设置P1.0为1</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>位地址（位寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>SETB</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SETB P2.3       ; 将 P2.3 设置为1</span></span></code></pre></div></li></ul><h3 id="_2-3-orl-or-logical-逻辑或" tabindex="-1"><strong>2.3 ORL（OR Logical，逻辑或）</strong> <a class="header-anchor" href="#_2-3-orl-or-logical-逻辑或" aria-label="Permalink to &quot;**2.3 ORL（OR Logical，逻辑或）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>对两个操作数的每一位进行逻辑“或”运算，结果存储在目标操作数中。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><strong>累加器与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL A, #0x0F</span></span></code></pre></div></li><li><strong>累加器与寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL A, R1</span></span></code></pre></div></li><li><strong>累加器与直接地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL A, 20H</span></span></code></pre></div></li><li><strong>直接地址与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL 30H, #0xF0</span></span></code></pre></div></li><li><strong>直接地址与累加器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL 40H, A</span></span></code></pre></div></li><li><strong>位地址与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL P1.0, #0x01</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li><li>直接地址（直接寻址）</li><li>位地址（位寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>立即数（立即寻址）</li><li>寄存器（寄存器寻址）</li><li>累加器 <code>A</code>（寄存器寻址）</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL A, #0xF0      ; A = A OR 0xF0</span></span>
<span class="line"><span>ORL 20H, A        ; 内存地址20H = 内存地址20H OR A</span></span>
<span class="line"><span>ORL P1.0, #0x01   ; P1.0 = P1.0 OR 1 (置位 P1.0)</span></span></code></pre></div></li></ul><h3 id="_2-4-xrl-xor-logical-逻辑异或" tabindex="-1"><strong>2.4 XRL（XOR Logical，逻辑异或）</strong> <a class="header-anchor" href="#_2-4-xrl-xor-logical-逻辑异或" aria-label="Permalink to &quot;**2.4 XRL（XOR Logical，逻辑异或）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>对两个操作数的每一位进行逻辑“异或”运算，结果存储在目标操作数中。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><strong>累加器与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL A, #0x0F</span></span></code></pre></div></li><li><strong>累加器与寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL A, R1</span></span></code></pre></div></li><li><strong>累加器与直接地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL A, 20H</span></span></code></pre></div></li><li><strong>直接地址与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL 30H, #0xF0</span></span></code></pre></div></li><li><strong>直接地址与累加器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL 40H, A</span></span></code></pre></div></li><li><strong>位地址与立即数</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL P1.0, #0x01</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li><li>直接地址（直接寻址）</li><li>位地址（位寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>立即数（立即寻址）</li><li>寄存器（寄存器寻址）</li><li>累加器 <code>A</code>（寄存器寻址）</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>XRL A, #0xFF      ; A = A XOR 0xFF</span></span>
<span class="line"><span>XRL 20H, A        ; 内存地址20H = 内存地址20H XOR A</span></span>
<span class="line"><span>XRL P1.0, #0x01   ; 切换 P1.0 的状态</span></span></code></pre></div></li></ul><h3 id="_2-5-rlc-rotate-left-through-carry-左旋转通过进位" tabindex="-1"><strong>2.5 RLC（Rotate Left through Carry，左旋转通过进位）</strong> <a class="header-anchor" href="#_2-5-rlc-rotate-left-through-carry-左旋转通过进位" aria-label="Permalink to &quot;**2.5 RLC（Rotate Left through Carry，左旋转通过进位）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>将累加器 <code>A</code> 的所有位向左旋转一位，最高位移入进位标志 <code>CY</code>，同时原 <code>CY</code> 标志位移入最低位。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RLC A</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>RLC</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, #0x80      ; A = 10000000</span></span>
<span class="line"><span>RLC A             ; A = 00000001, CY = 1</span></span></code></pre></div></li></ul><h3 id="_2-6-pop-从堆栈弹出数据" tabindex="-1"><strong>2.6 POP（从堆栈弹出数据）</strong> <a class="header-anchor" href="#_2-6-pop-从堆栈弹出数据" aria-label="Permalink to &quot;**2.6 POP（从堆栈弹出数据）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>从堆栈中弹出一个字节，并将其存储到目标操作数中。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POP target</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>寄存器（R0-R7）</li><li>特殊功能寄存器（如 <code>DPTR</code>、<code>DPL</code>、<code>DPH</code>）</li><li>直接地址</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>POP</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POP R0            ; 将堆栈顶部的字节弹出到寄存器 R0</span></span>
<span class="line"><span>POP DPTR          ; 将堆栈顶部的字节弹出到 DPTR（注意：DPTR 是16位，需要两个 POP 指令）</span></span></code></pre></div></li></ul><h3 id="_2-7-mov-move-数据传送" tabindex="-1"><strong>2.7 MOV（Move，数据传送）</strong> <a class="header-anchor" href="#_2-7-mov-move-数据传送" aria-label="Permalink to &quot;**2.7 MOV（Move，数据传送）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>将数据从源操作数传送到目标操作数。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><strong>立即到寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, #0x55</span></span>
<span class="line"><span>MOV R1, #0xAA</span></span></code></pre></div></li><li><strong>寄存器到寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, R0</span></span>
<span class="line"><span>MOV R1, R2</span></span></code></pre></div></li><li><strong>直接地址到寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, 20H</span></span></code></pre></div></li><li><strong>寄存器到直接地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV 30H, A</span></span></code></pre></div></li><li><strong>直接地址到直接地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV 40H, 50H</span></span></code></pre></div></li><li><strong>位地址到位地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV P1.0, P2.0</span></span></code></pre></div></li><li><strong>寄存器到位地址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV P1.0, R0</span></span></code></pre></div></li><li><strong>位地址到寄存器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV R0, P1.0</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li><li>通用寄存器（R0-R7）（寄存器寻址）</li><li>直接地址（直接寻址）</li><li>位地址（位寻址）</li><li>特殊功能寄存器（SFR）（直接寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>立即数（立即寻址）</li><li>寄存器（寄存器寻址）</li><li>直接地址（直接寻址）</li><li>位地址（位寻址）</li></ul></li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能直接在 <code>MOV</code> 指令中移动两个直接地址之间的数据。</li><li>不能直接将 SFR 之间的数据移动，除非特定条件满足。</li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, #0xFF        ; 将立即数0xFF加载到累加器 A</span></span>
<span class="line"><span>MOV R1, A           ; 将 A 的内容移动到 R1</span></span>
<span class="line"><span>MOV 20H, R1         ; 将 R1 的内容移动到内部RAM地址20H</span></span>
<span class="line"><span>MOV P1.0, A         ; 将 A 的最低位移动到 P1.0</span></span></code></pre></div></li></ul><h3 id="_2-8-movx-move-external-外部数据移动" tabindex="-1"><strong>2.8 MOVX（Move External，外部数据移动）</strong> <a class="header-anchor" href="#_2-8-movx-move-external-外部数据移动" aria-label="Permalink to &quot;**2.8 MOVX（Move External，外部数据移动）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>在累加器 <code>A</code> 和外部数据存储器（外部RAM或I/O端口）之间移动数据。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><strong>累加器到外部存储器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOVX @DPTR, A     ; 将 A 的内容写入外部存储器地址由 DPTR 指向的位置</span></span></code></pre></div></li><li><strong>外部存储器到累加器</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOVX A, @DPTR     ; 从外部存储器地址由 DPTR 指向的位置读取数据到 A</span></span></code></pre></div></li><li><strong>累加器到外部数据寄存器</strong>（例如，使用 <code>MOVX @R0, A</code>）</li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>外部存储器地址（通过 <code>@DPTR</code> 或 <code>@R0</code>、<code>@R1</code>）</li></ul></li><li><strong>源操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV DPTR, #0x8000  ; 设置 DPTR 指向外部RAM地址0x8000</span></span>
<span class="line"><span>MOV A, #0x55        ; 将0x55加载到累加器 A</span></span>
<span class="line"><span>MOVX @DPTR, A       ; 将 A 的内容写入外部RAM地址0x8000</span></span>
<span class="line"><span>MOVX A, @DPTR       ; 从外部RAM地址0x8000读取数据到 A</span></span></code></pre></div></li></ul><h3 id="_2-9-movc-move-code-代码数据移动" tabindex="-1"><strong>2.9 MOVC（Move Code，代码数据移动）</strong> <a class="header-anchor" href="#_2-9-movc-move-code-代码数据移动" aria-label="Permalink to &quot;**2.9 MOVC（Move Code，代码数据移动）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>根据累加器 <code>A</code> 或程序计数器 <code>PC</code> 的内容，从代码存储器（ROM）中读取数据到累加器 <code>A</code>。</li></ul></li><li><p><strong>语法</strong>：</p><ul><li><strong>使用 <code>DPTR</code> 作为基址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOVC A, @A + DPTR  ; 从代码存储器地址 DPTR + A 读取数据到 A</span></span></code></pre></div></li><li><strong>使用 <code>PC</code> 作为基址</strong>：<div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOVC A, @A + PC    ; 从代码存储器地址 PC + A 读取数据到 A</span></span></code></pre></div></li></ul></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>累加器 <code>A</code>（寄存器寻址）</li></ul></li><li><strong>源操作数</strong>： <ul><li><code>@A + DPTR</code> 或 <code>@A + PC</code>（代码存储器间接寻址）</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV DPTR, #TABLE_HIGH   ; 设置 DPTR 指向查找表高位部分</span></span>
<span class="line"><span>MOV A, #10              ; 将 X=10 加载到累加器 A</span></span>
<span class="line"><span>MOVC A, @A + DPTR       ; 从 TABLE_HIGH[X] 读取高位字节到 A</span></span></code></pre></div></li></ul><hr><h2 id="_3-跳转指令详解" tabindex="-1"><strong>3. 跳转指令详解</strong> <a class="header-anchor" href="#_3-跳转指令详解" aria-label="Permalink to &quot;**3. 跳转指令详解**&quot;">​</a></h2><h3 id="_3-1-sjmp-short-jump-短跳转" tabindex="-1"><strong>3.1 SJMP（Short Jump，短跳转）</strong> <a class="header-anchor" href="#_3-1-sjmp-short-jump-短跳转" aria-label="Permalink to &quot;**3.1 SJMP（Short Jump，短跳转）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>无条件地跳转到相对于当前指令地址的一个偏移位置。跳转范围为 -128 到 +127 条指令。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SJMP label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>相对地址（相对于当前指令的位置）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>SJMP</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>SJMP MAIN_LOOP    ; 跳转到标签 MAIN_LOOP</span></span></code></pre></div></li></ul><h3 id="_3-2-ljmp-long-jump-长跳转" tabindex="-1"><strong>3.2 LJMP（Long Jump，长跳转）</strong> <a class="header-anchor" href="#_3-2-ljmp-long-jump-长跳转" aria-label="Permalink to &quot;**3.2 LJMP（Long Jump，长跳转）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>无条件地跳转到代码存储器中的一个绝对地址。跳转范围覆盖整个代码存储器。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LJMP address</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>绝对地址（16位地址）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>LJMP</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LJMP 0x1000       ; 跳转到绝对地址0x1000</span></span></code></pre></div></li></ul><h3 id="_3-3-ajmp-absolute-jump-绝对跳转" tabindex="-1"><strong>3.3 AJMP（Absolute Jump，绝对跳转）</strong> <a class="header-anchor" href="#_3-3-ajmp-absolute-jump-绝对跳转" aria-label="Permalink to &quot;**3.3 AJMP（Absolute Jump，绝对跳转）**&quot;">​</a></h3><ul><li><p><strong>功能</strong>：</p><ul><li>无条件地跳转到代码存储器中的一个绝对地址。跳转范围为当前页的256字节内。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AJMP label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>绝对地址（11位地址，当前页内）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>AJMP</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AJMP SQUARE       ; 跳转到标签 SQUARE（前提是 SQUARE 在当前页内）</span></span></code></pre></div></li></ul><h3 id="_3-4-条件跳转指令" tabindex="-1"><strong>3.4 条件跳转指令</strong> <a class="header-anchor" href="#_3-4-条件跳转指令" aria-label="Permalink to &quot;**3.4 条件跳转指令**&quot;">​</a></h3><p>这些指令基于某些条件标志（如零标志 <code>Z</code>, 进位标志 <code>CY</code> 等）进行跳转。</p><h4 id="_3-4-1-jz-jump-if-zero-零跳转" tabindex="-1"><strong>3.4.1 JZ（Jump if Zero，零跳转）</strong> <a class="header-anchor" href="#_3-4-1-jz-jump-if-zero-零跳转" aria-label="Permalink to &quot;**3.4.1 JZ（Jump if Zero，零跳转）**&quot;">​</a></h4><ul><li><p><strong>功能</strong>：</p><ul><li>如果零标志 <code>Z</code> 被设置（即上一个操作的结果为零），则跳转到指定的标签。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JZ label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>相对地址（相对于当前指令的位置）</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>JZ</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JZ END_PROGRAM    ; 如果 Z=1，则跳转到 END_PROGRAM</span></span></code></pre></div></li></ul><h4 id="_3-4-2-jnz-jump-if-not-zero-非零跳转" tabindex="-1"><strong>3.4.2 JNZ（Jump if Not Zero，非零跳转）</strong> <a class="header-anchor" href="#_3-4-2-jnz-jump-if-not-zero-非零跳转" aria-label="Permalink to &quot;**3.4.2 JNZ（Jump if Not Zero，非零跳转）**&quot;">​</a></h4><ul><li><p><strong>功能</strong>：</p><ul><li>如果零标志 <code>Z</code> 未被设置（即上一个操作的结果不为零），则跳转到指定的标签。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JNZ label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>相对地址</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>JNZ</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JNZ PROCESS_DATA   ; 如果 Z=0，则跳转到 PROCESS_DATA</span></span></code></pre></div></li></ul><h4 id="_3-4-3-jc-jump-if-carry-进位跳转" tabindex="-1"><strong>3.4.3 JC（Jump if Carry，进位跳转）</strong> <a class="header-anchor" href="#_3-4-3-jc-jump-if-carry-进位跳转" aria-label="Permalink to &quot;**3.4.3 JC（Jump if Carry，进位跳转）**&quot;">​</a></h4><ul><li><p><strong>功能</strong>：</p><ul><li>如果进位标志 <code>CY</code> 被设置，则跳转到指定的标签。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JC label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>相对地址</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>JC</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JC OVERFLOW_ERROR   ; 如果 CY=1，则跳转到 OVERFLOW_ERROR</span></span></code></pre></div></li></ul><h4 id="_3-4-4-jnc-jump-if-no-carry-无进位跳转" tabindex="-1"><strong>3.4.4 JNC（Jump if No Carry，无进位跳转）</strong> <a class="header-anchor" href="#_3-4-4-jnc-jump-if-no-carry-无进位跳转" aria-label="Permalink to &quot;**3.4.4 JNC（Jump if No Carry，无进位跳转）**&quot;">​</a></h4><ul><li><p><strong>功能</strong>：</p><ul><li>如果进位标志 <code>CY</code> 未被设置，则跳转到指定的标签。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JNC label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>相对地址</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>JNC</code> 是单目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JNC CONTINUE_PROCESS ; 如果 CY=0，则跳转到 CONTINUE_PROCESS</span></span></code></pre></div></li></ul><h4 id="_3-4-5-jbc-jump-if-bit-set-and-clear-bit-位跳转并清位" tabindex="-1"><strong>3.4.5 JBC（Jump if Bit set and Clear bit，位跳转并清位）</strong> <a class="header-anchor" href="#_3-4-5-jbc-jump-if-bit-set-and-clear-bit-位跳转并清位" aria-label="Permalink to &quot;**3.4.5 JBC（Jump if Bit set and Clear bit，位跳转并清位）**&quot;">​</a></h4><ul><li><p><strong>功能</strong>：</p><ul><li>如果指定的位被设置，则跳转到指定的标签，并将该位清零。</li></ul></li><li><p><strong>语法</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JBC bit, label</span></span></code></pre></div></li><li><p><strong>寻址方式</strong>：</p><ul><li><strong>目标操作数</strong>： <ul><li>位地址（位寻址）</li><li>相对地址</li></ul></li><li><strong>源操作数</strong>： <ul><li>无源操作数，<code>JBC</code> 是双目操作数指令。</li></ul></li></ul></li><li><p><strong>示例</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JBC P1.0, RESET_FLAG   ; 如果 P1.0=1，则跳转到 RESET_FLAG，并将 P1.0清零</span></span></code></pre></div></li></ul><hr><h2 id="_4-逻辑指令综合表" tabindex="-1"><strong>4. 逻辑指令综合表</strong> <a class="header-anchor" href="#_4-逻辑指令综合表" aria-label="Permalink to &quot;**4. 逻辑指令综合表**&quot;">​</a></h2><p>为了更清晰地了解每个逻辑指令的寻址方式和允许的操作数，以下是一个综合表格：</p><table tabindex="0"><thead><tr><th>指令</th><th>功能</th><th>目标操作数寻址方式</th><th>源操作数寻址方式</th><th>允许的目标操作数</th><th>允许的源操作数</th></tr></thead><tbody><tr><td><code>CPL</code></td><td>取反</td><td>寄存器寻址，位寻址</td><td>无</td><td><code>A</code>，位地址</td><td>无</td></tr><tr><td><code>SETB</code></td><td>置位</td><td>位寻址</td><td>无</td><td>位地址</td><td>无</td></tr><tr><td><code>ORL</code></td><td>逻辑或</td><td>寄存器寻址，直接寻址，位寻址</td><td>立即寻址，寄存器寻址，<code>A</code></td><td><code>A</code>，直接地址，位地址</td><td>立即数，寄存器，<code>A</code></td></tr><tr><td><code>XRL</code></td><td>逻辑异或</td><td>寄存器寻址，直接寻址，位寻址</td><td>立即寻址，寄存器寻址，<code>A</code></td><td><code>A</code>，直接地址，位地址</td><td>立即数，寄存器，<code>A</code></td></tr><tr><td><code>RLC</code></td><td>左旋转通过进位</td><td>寄存器寻址</td><td>无</td><td><code>A</code></td><td>无</td></tr><tr><td><code>POP</code></td><td>从堆栈弹出数据</td><td>寄存器寻址，直接寻址，SFR</td><td>无</td><td><code>R0-R7</code>，<code>DPTR</code>，直接地址</td><td>无</td></tr><tr><td><code>MOV</code></td><td>数据传送</td><td>多种</td><td>多种</td><td><code>A</code>，寄存器，直接地址，位地址，SFR</td><td>立即数，寄存器，直接地址，位地址</td></tr><tr><td><code>MOVX</code></td><td>外部数据移动</td><td>外部存储器地址</td><td><code>A</code></td><td><code>@DPTR</code>，<code>@R0</code>，<code>@R1</code></td><td><code>A</code></td></tr><tr><td><code>MOVC</code></td><td>代码数据移动</td><td>累加器 + <code>DPTR</code> 或 <code>PC</code></td><td>无</td><td><code>A</code></td><td>无</td></tr><tr><td><strong>跳转指令</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>SJMP</code></td><td>短跳转</td><td>相对地址</td><td>无</td><td>相对地址</td><td>无</td></tr><tr><td><code>LJMP</code></td><td>长跳转</td><td>绝对地址</td><td>无</td><td>绝对地址</td><td>无</td></tr><tr><td><code>AJMP</code></td><td>绝对跳转</td><td>绝对地址（当前页内）</td><td>无</td><td>绝对地址</td><td>无</td></tr><tr><td><code>JZ</code></td><td>零跳转</td><td>相对地址</td><td>无</td><td>相对地址</td><td>无</td></tr><tr><td><code>JNZ</code></td><td>非零跳转</td><td>相对地址</td><td>无</td><td>相对地址</td><td>无</td></tr><tr><td><code>JC</code></td><td>进位跳转</td><td>相对地址</td><td>无</td><td>相对地址</td><td>无</td></tr><tr><td><code>JNC</code></td><td>无进位跳转</td><td>相对地址</td><td>无</td><td>相对地址</td><td>无</td></tr><tr><td><code>JBC</code></td><td>位跳转并清位</td><td>位寻址 + 相对地址</td><td>无</td><td>位地址 + 相对地址</td><td>无</td></tr></tbody></table><hr><h2 id="_5-示例解析" tabindex="-1"><strong>5. 示例解析</strong> <a class="header-anchor" href="#_5-示例解析" aria-label="Permalink to &quot;**5. 示例解析**&quot;">​</a></h2><p>为了更好地理解这些指令的用法，以下是几个具体示例及其解析。</p><h3 id="示例1-使用-cpl-和-setb" tabindex="-1"><strong>示例1：使用 <code>CPL</code> 和 <code>SETB</code></strong> <a class="header-anchor" href="#示例1-使用-cpl-和-setb" aria-label="Permalink to &quot;**示例1：使用 `CPL` 和 `SETB`**&quot;">​</a></h3><p><strong>需求</strong>：切换累加器 <code>A</code> 的所有位，并将 <code>P1.0</code> 置位。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, #0x0F    ; A = 00001111</span></span>
<span class="line"><span>CPL A            ; A = 11110000</span></span>
<span class="line"><span>SETB P1.0        ; P1.0 = 1</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>MOV A, #0x0F</code></strong>：</p><ul><li>将立即数 <code>0x0F</code>（00001111）加载到累加器 <code>A</code> 中。</li></ul></li><li><p><strong><code>CPL A</code></strong>：</p><ul><li>取反 <code>A</code> 中的每一位，结果 <code>A</code> = <code>0xF0</code>（11110000）。</li></ul></li><li><p><strong><code>SETB P1.0</code></strong>：</p><ul><li>将 <code>P1.0</code> 位设置为 <code>1</code>。</li></ul></li></ol><h3 id="示例2-使用-orl-和-xrl" tabindex="-1"><strong>示例2：使用 <code>ORL</code> 和 <code>XRL</code></strong> <a class="header-anchor" href="#示例2-使用-orl-和-xrl" aria-label="Permalink to &quot;**示例2：使用 `ORL` 和 `XRL`**&quot;">​</a></h3><p><strong>需求</strong>：将 <code>P1</code> 端口的高四位置位，同时切换低四位。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ORL P1, #0xF0    ; 设置P1.4-P1.7为1，保持P1.0-P1.3不变</span></span>
<span class="line"><span>XRL P1, #0x0F    ; 切换P1.0-P1.3的状态</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>ORL P1, #0xF0</code></strong>：</p><ul><li>对 <code>P1</code> 的每一位进行逻辑“或”操作，设置高四位 <code>P1.4-P1.7</code> 为 <code>1</code>。</li></ul></li><li><p><strong><code>XRL P1, #0x0F</code></strong>：</p><ul><li>对 <code>P1</code> 的低四位 <code>P1.0-P1.3</code> 进行逻辑“异或”操作，切换其状态。</li></ul></li></ol><h3 id="示例3-使用-rlc" tabindex="-1"><strong>示例3：使用 <code>RLC</code></strong> <a class="header-anchor" href="#示例3-使用-rlc" aria-label="Permalink to &quot;**示例3：使用 `RLC`**&quot;">​</a></h3><p><strong>需求</strong>：将累加器 <code>A</code> 左旋转，通过进位，并检查进位标志。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV A, #0x80    ; A = 10000000</span></span>
<span class="line"><span>RLC A            ; A = 00000001, CY = 1</span></span>
<span class="line"><span>JC SET_LED       ; 如果进位被设置，则跳转到 SET_LED</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>MOV A, #0x80</code></strong>：</p><ul><li>将 <code>0x80</code>（10000000）加载到累加器 <code>A</code> 中。</li></ul></li><li><p><strong><code>RLC A</code></strong>：</p><ul><li>左旋转 <code>A</code>，最高位移入 <code>CY</code>，并将 <code>CY</code> 的原值移入最低位。</li><li>结果：<code>A</code> = <code>0x01</code>（00000001），<code>CY</code> = <code>1</code>。</li></ul></li><li><p><strong><code>JC SET_LED</code></strong>：</p><ul><li>检查 <code>CY</code> 标志，如果 <code>CY=1</code>，则跳转到标签 <code>SET_LED</code>。</li></ul></li></ol><h3 id="示例4-使用-pop" tabindex="-1"><strong>示例4：使用 <code>POP</code></strong> <a class="header-anchor" href="#示例4-使用-pop" aria-label="Permalink to &quot;**示例4：使用 `POP`**&quot;">​</a></h3><p><strong>需求</strong>：从堆栈中弹出一个字节到寄存器 <code>R0</code>。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POP R0          ; 弹出堆栈顶部的字节到 R0</span></span></code></pre></div><p><strong>解析</strong>：</p><ul><li><strong><code>POP R0</code></strong>： <ul><li>从堆栈中弹出一个字节，并将其存储到寄存器 <code>R0</code> 中。</li><li>堆栈指针 <code>SP</code> 增加1，指向下一个堆栈地址。</li></ul></li></ul><h3 id="示例5-使用-mov-和-movx" tabindex="-1"><strong>示例5：使用 <code>MOV</code> 和 <code>MOVX</code></strong> <a class="header-anchor" href="#示例5-使用-mov-和-movx" aria-label="Permalink to &quot;**示例5：使用 `MOV` 和 `MOVX`**&quot;">​</a></h3><p><strong>需求</strong>：将累加器 <code>A</code> 的值 <code>0x55</code> 写入外部RAM地址 <code>0x8000</code>，然后从该地址读取回 <code>A</code>。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV DPTR, #0x8000    ; 设置 DPTR 指向外部RAM地址0x8000</span></span>
<span class="line"><span>MOV A, #0x55          ; A = 0x55</span></span>
<span class="line"><span>MOVX @DPTR, A        ; 将 A 的值写入外部RAM地址0x8000</span></span>
<span class="line"><span>MOVX A, @DPTR        ; 从外部RAM地址0x8000读取数据到 A</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>MOV DPTR, #0x8000</code></strong>：</p><ul><li>将数据指针寄存器 <code>DPTR</code> 设置为外部RAM地址 <code>0x8000</code>。</li></ul></li><li><p><strong><code>MOV A, #0x55</code></strong>：</p><ul><li>将立即数 <code>0x55</code>（01010101）加载到累加器 <code>A</code> 中。</li></ul></li><li><p><strong><code>MOVX @DPTR, A</code></strong>：</p><ul><li>将累加器 <code>A</code> 的内容写入外部RAM地址 <code>0x8000</code>。</li></ul></li><li><p><strong><code>MOVX A, @DPTR</code></strong>：</p><ul><li>从外部RAM地址 <code>0x8000</code> 读取数据到累加器 <code>A</code> 中。</li></ul></li></ol><h3 id="示例6-使用-movc" tabindex="-1"><strong>示例6：使用 <code>MOVC</code></strong> <a class="header-anchor" href="#示例6-使用-movc" aria-label="Permalink to &quot;**示例6：使用 `MOVC`**&quot;">​</a></h3><p><strong>需求</strong>：从代码存储器中查找一个值，根据 <code>DPTR</code> 和 <code>A</code> 的内容读取数据到 <code>A</code>。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MOV DPTR, #TABLE    ; 设置 DPTR 指向查找表TABLE</span></span>
<span class="line"><span>MOV A, #0x05        ; A = 5</span></span>
<span class="line"><span>MOVC A, @A + DPTR   ; 从 TABLE[5] 读取数据到 A</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>MOV DPTR, #TABLE</code></strong>：</p><ul><li>将数据指针寄存器 <code>DPTR</code> 设置为查找表 <code>TABLE</code> 的起始地址。</li></ul></li><li><p><strong><code>MOV A, #0x05</code></strong>：</p><ul><li>将立即数 <code>0x05</code>（5）加载到累加器 <code>A</code> 中。</li></ul></li><li><p><strong><code>MOVC A, @A + DPTR</code></strong>：</p><ul><li>计算地址 <code>DPTR + A</code>，即 <code>TABLE + 5</code>，从代码存储器中读取该地址的数据到 <code>A</code> 中。</li></ul></li></ol><hr><h2 id="_6-总结与学习要点" tabindex="-1"><strong>6. 总结与学习要点</strong> <a class="header-anchor" href="#_6-总结与学习要点" aria-label="Permalink to &quot;**6. 总结与学习要点**&quot;">​</a></h2><ol><li><p><strong>理解每个指令的功能</strong>：</p><ul><li><code>CPL</code>：按位取反。</li><li><code>SETB</code>：设置特定位为1。</li><li><code>ORL</code>：逻辑“或”运算。</li><li><code>XRL</code>：逻辑“异或”运算。</li><li><code>RLC</code>：左旋转通过进位。</li><li><code>POP</code>：从堆栈弹出数据。</li><li><code>MOV</code>：数据传送。</li><li><code>MOVX</code>：外部数据移动。</li><li><code>MOVC</code>：代码数据移动。</li><li>跳转指令（<code>SJMP</code>, <code>LJMP</code>, <code>AJMP</code>, <code>JZ</code>, <code>JNZ</code>, <code>JC</code>, <code>JNC</code>, <code>JBC</code>）：控制程序流程。</li></ul></li><li><p><strong>掌握寻址方式</strong>：</p><ul><li>不同指令支持不同的寻址方式，理解这些限制对于正确使用指令至关重要。</li><li><strong>单目指令</strong>（如 <code>CPL</code>, <code>SETB</code>, <code>RLC</code>, <code>POP</code>）通常只有一个目标操作数。</li><li><strong>双目指令</strong>（如 <code>ORL</code>, <code>XRL</code>, <code>MOV</code>）有目标和源操作数，需了解各自的寻址限制。</li></ul></li><li><p><strong>熟悉标志位影响</strong>：</p><ul><li>某些指令会影响程序状态字寄存器（PSW）的标志位，如 <code>CPL</code>, <code>ORL</code>, <code>XRL</code>, <code>RLC</code> 等。</li><li>跳转指令通常基于标志位的状态进行条件跳转。</li></ul></li><li><p><strong>编程实践</strong>：</p><ul><li>通过实际编写和调试代码，巩固指令的理解和应用。</li><li>例如，使用 <code>ORL</code> 和 <code>XRL</code> 指令进行位操作，利用 <code>POP</code> 和 <code>PUSH</code> 管理堆栈数据。</li></ul></li><li><p><strong>查阅参考资料</strong>：</p><ul><li>使用官方或权威的8051汇编语言手册，获取指令的详细信息和使用示例。</li></ul></li><li><p><strong>逻辑与跳转指令的结合使用</strong>：</p><ul><li>逻辑指令通常与条件跳转指令结合使用，实现复杂的控制逻辑和数据处理。</li></ul></li></ol><hr><h2 id="附加示例-综合使用逻辑和跳转指令" tabindex="-1"><strong>附加示例：综合使用逻辑和跳转指令</strong> <a class="header-anchor" href="#附加示例-综合使用逻辑和跳转指令" aria-label="Permalink to &quot;**附加示例：综合使用逻辑和跳转指令**&quot;">​</a></h2><p><strong>需求</strong>：检测 <code>P1.0</code> 是否被置位，如果是，则取反 <code>P2.0</code>，否则设置 <code>P2.0</code>。</p><p><strong>代码</strong>：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>START:</span></span>
<span class="line"><span>    JB P1.0, CHECK_BIT   ; 如果 P1.0 = 1，跳转到 CHECK_BIT</span></span>
<span class="line"><span>    SETB P2.0            ; 否则，设置 P2.0 = 1</span></span>
<span class="line"><span>    SJMP START           ; 跳转回 START</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CHECK_BIT:</span></span>
<span class="line"><span>    CPL P2.0             ; 取反 P2.0</span></span>
<span class="line"><span>    SJMP START           ; 跳转回 START</span></span></code></pre></div><p><strong>解析</strong>：</p><ol><li><p><strong><code>JB P1.0, CHECK_BIT</code></strong>：</p><ul><li>检查 <code>P1.0</code> 位是否为1，如果是，则跳转到 <code>CHECK_BIT</code>。</li></ul></li><li><p><strong><code>SETB P2.0</code></strong>：</p><ul><li>如果 <code>P1.0</code> 位为0，则执行此指令，将 <code>P2.0</code> 设置为1。</li></ul></li><li><p><strong><code>SJMP START</code></strong>：</p><ul><li>无条件地跳转回 <code>START</code>，形成循环。</li></ul></li><li><p><strong><code>CHECK_BIT:</code> 标签</strong>：</p><ul><li><strong><code>CPL P2.0</code></strong>：取反 <code>P2.0</code> 的状态。</li><li><strong><code>SJMP START</code></strong>：无条件地跳转回 <code>START</code>。</li></ul></li></ol><p><strong>结果</strong>：</p><ul><li><strong>当 <code>P1.0 = 1</code></strong>： <ul><li>执行 <code>CPL P2.0</code>，取反 <code>P2.0</code> 的状态。</li></ul></li><li><strong>当 <code>P1.0 = 0</code></strong>： <ul><li>执行 <code>SETB P2.0</code>，将 <code>P2.0</code> 设置为1。</li></ul></li></ul><hr><h2 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h2><p>使用特殊寄存器属于直接寻址，而非寄存器选址。</p><p>I/O端口（如P1）也属于直接寻址，而（P1.1）属于位寻址。</p></div></div></div></div><div class="sidebar"><div class="a-card has-border"><div class="avatar-wrapper"><img src="https://resource-un4.pages.dev/article/yjtp.webp" alt="57D02" class="avatar"></div><div class="profile-content"><h2 class="name">57D02</h2><div class="position">全栈开发、优化算法爱好者</div><p class="bio">红红火火恍恍惚惚</p><div class="social-links"><!--[--><a href="https://github.com/57Darling02/" target="_blank" class="social-item" title="GitHub"><i class="fa-brands fa-github"></i></a><a href="57Darling02@outlook.com" target="_blank" class="social-item" title="邮箱"><i class="fa-regular fa-envelope"></i></a><!--]--></div></div></div><div class="sidebar-stay"><div class="toc-card a-card" data-v-87e3c8fa><i class="fas fa-columns" data-v-87e3c8fa></i><span class="toc-title" style="font-weight:600;" data-v-87e3c8fa>目录导航</span><!----></div><!----></div></div></div></div><div class="footer-container" style="color:white;margin-bottom:250px;"><span class="el-tag el-tag--success el-tag--small el-tag--plain is-round" style=""><span class="el-tag__content"><!--[-->Copyright © 2025-present 57D02<!--]--></span><!--v-if--></span></div><!--]--></div></div><!--[--><div class="el-scrollbar__bar is-horizontal" style="display:none;"><div class="el-scrollbar__thumb" style="width:;transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical" style="display:none;"><div class="el-scrollbar__thumb" style="height:;transform:translateY(0%);"></div></div><!--]--></div></div><!--]--></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about_index.md\":\"CFAEjL6z\",\"index.md\":\"53GAllBb\",\"posts_20240916-2.md\":\"BrrLuliS\",\"posts_20240916.md\":\"rNaj1uo2\",\"posts_20240923.md\":\"51bgABOW\",\"posts_20241026_无眠夜.md\":\"Bru5EZVu\",\"posts_51stc_uart.md\":\"c8Z7CIGv\",\"posts_cloudflare_free.md\":\"BORGSdAE\",\"posts_columngeneration.md\":\"DIrRqdEe\",\"posts_ftp.md\":\"DbITc8nZ\",\"posts_hahha.md\":\"-Hhkwq3b\",\"posts_hello-world.md\":\"C8fqdsdS\",\"posts_hexo快速创作指南.md\":\"DsB3ZzvQ\",\"posts_ksweb.md\":\"BS6L_YFA\",\"posts_sao-uw-1.md\":\"__1vQ-M0\",\"posts_sao-uw-2.md\":\"Cq2bidW-\",\"posts_sao-uw-3.md\":\"COliM_TI\",\"posts_sao-uw-4.md\":\"BhWZPR2v\",\"posts_sao-uw-5.md\":\"D2zeVyhu\",\"posts_sao-uw-6.md\":\"CnNvjKJV\",\"posts_sao-uw-7.md\":\"CRotV9VW\",\"posts_sao-uw-8.md\":\"CEqj8CIW\",\"posts_search_method2.md\":\"Dr-2CCpw\",\"posts_searchmethod.md\":\"CyeQEXTn\",\"posts_searchmethods3.md\":\"CzcLmAiA\",\"posts_交叉口的轨迹规划的一些探索.md\":\"B3QfRC6n\",\"posts_单纯形法.md\":\"DsJT1e47\",\"posts_如何写一篇hexo博客.md\":\"BtrJtoeD\",\"posts_嵌入式学习.md\":\"wZuBU8TE\",\"posts_我家邻居蛇精病.md\":\"BmciBLcp\",\"posts_生产工具.md\":\"CYfRWOxn\",\"posts_运筹线性规划.md\":\"DF5CMSaj\",\"posts_逆向初体验.md\":\"IvKd-0tk\",\"posts_钟情.md\":\"DaLedH-f\",\"readme.md\":\"BBiXmc8A\",\"tags_index.md\":\"ByRo0yQA\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"57D02\",\"description\":\"A VitePress Site\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"mainTitle\":\"57D02\",\"subTitles\":[\"全栈开发爱好者\",\"算法优化爱好者\",\"软件开发爱好者\",\"安卓与嵌入式开发爱好者\"],\"defaultauthor\":\"57D02\",\"logo\":\"https://resource-un4.pages.dev/article/yjtp.webp\",\"siteTitle\":\"57D02\",\"menuItems\":[{\"label\":\"我的网址\",\"icon\":\"fal fa-browser\",\"children\":[{\"key\":\"action1\",\"label\":\"闪装智拼\",\"icon\":\"fa-light fa-cubes\",\"link\":\"https://box.57d02.cn\"},{\"key\":\"action2\",\"label\":\"alist云盘\",\"icon\":\"fa-light fa-cloud\",\"link\":\"https://alist.57d02.cn\"}]},{\"label\":\"更多功能\",\"icon\":\"fa-solid fa-list\",\"children\":[{\"key\":\"action1\",\"label\":\"付费CSDN解析\",\"icon\":\"fa-light fa-magnifying-glass-chart\",\"link\":\"https://mark.cuckooing.cn/\"},{\"key\":\"action2\",\"label\":\"关于\",\"icon\":\"fa-light fa-address-card\",\"link\":\"About\"},{\"key\":\"music\",\"label\":\"音乐\",\"icon\":\"fa-light fa-music\",\"link\":\"/music/\"},{\"key\":\"movies\",\"label\":\"电影\",\"icon\":\"fa-light fa-video\",\"link\":\"/movies/\"},{\"key\":\"archives\",\"label\":\"归档\",\"icon\":\"fa-light fa-archive\",\"link\":\"/archives/\"},{\"key\":\"tags\",\"label\":\"标签\",\"icon\":\"fa-light fa-tags\",\"link\":\"/Tags/\"},{\"key\":\"categories\",\"label\":\"分类\",\"icon\":\"fa-light fa-folder-open\",\"link\":\"/categories/\"},{\"key\":\"link\",\"label\":\"链接\",\"icon\":\"fa-light fa-link\",\"link\":\"/link/\"}]}],\"avatar\":\"https://resource-un4.pages.dev/article/yjtp.webp\",\"name\":\"57D02\",\"position\":\"全栈开发、优化算法爱好者\",\"bio\":\"红红火火恍恍惚惚\",\"socialLinks\":[{\"name\":\"GitHub\",\"icon\":\"fa-brands fa-github\",\"url\":\"https://github.com/57Darling02/\"},{\"name\":\"邮箱\",\"icon\":\"fa-regular fa-envelope\",\"url\":\"57Darling02@outlook.com\"}],\"footer\":{\"message\":\"VitePress\",\"copyright\":\"Copyright © 2025-present 57D02\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>